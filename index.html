<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Page Replacement Algorithm Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        /* Cyberpunk Background */
        body {
            position: relative;
            min-height: 100vh;
            overflow-x: hidden;
            color: #e2e8f0;
        }
        
        .cyber-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }
        
        .cyber-grid {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(20, 20, 60, 0.7) 1px, transparent 1px),
                linear-gradient(90deg, rgba(20, 20, 60, 0.7) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        
        .cyber-scanlines {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                rgba(0, 255, 255, 0.08) 1px, 
                transparent 1px
            );
            background-size: 100% 3px;
            animation: scan 8s linear infinite;
        }
        
        @keyframes scan {
            from { transform: translateY(-100%); }
            to { transform: translateY(100%); }
        }

        /* Original Styles */
        .frame-pulse {
            animation: pulse 0.5s ease-in-out;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .current-page {
            background-color: #4f46e5;
            color: white;
        }
        .page-fault {
            background-color: #ef4444;
            color: white;
        }
        .page-hit {
            background-color: #10b981;
            color: white;
        }

        /* UI Containers */
        .sim-container {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(100, 200, 255, 0.15);
            box-shadow: 
                0 0 30px rgba(0, 150, 255, 0.2),
                inset 0 0 15px rgba(100, 200, 255, 0.1);
        }

        /* New Features Styles */
        .help-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%234f46e5"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>');
            cursor: help;
            margin-left: 5px;
        }
        .gif-tooltip {
            position: absolute;
            z-index: 100;
            display: none;
            border: 2px solid #4f46e5;
            border-radius: 8px;
            background: #111827;
            padding: 5px;
        }
        #chartContainer {
            height: 200px;
            margin-top: 20px;
            display: none;
        }
        #presets {
            margin-left: 10px;
            padding: 8px;
            background: #1e293b;
            color: white;
            border-radius: 6px;
        }
        #exportBtn {
            background: #7c3aed;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            margin-left: 10px;
        }
        #soundToggle {
            background: #1e293b;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            margin-left: 10px;
        }
        
        /* New Enhanced Styles */
        .theme-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30, 41, 59, 0.7);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
        }
        
        .tour-highlight {
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.6);
            animation: highlight-pulse 1.5s infinite;
        }
        
        @keyframes highlight-pulse {
            0% { box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.2); }
            50% { box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.8); }
            100% { box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.2); }
        }
        .light-theme {
            color: #1e293b;
            background: #f1f5f9;
        }
        
        .light-theme .sim-container {
            background: rgba(255, 255, 255, 0.85);
            color: #1e293b;
        }
        
        .light-theme .cyber-bg {
            background: linear-gradient(135deg, #e2e8f0, #cbd5e1, #94a3b8);
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 150, 255, 0.3);
        }
        
        .algorithm-animation {
            height: 120px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .algorithm-details {
            display: none;
            padding: 10px;
            margin-top: 10px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
        }
        
        .tab-container {
            display: flex;
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
            margin-bottom: 10px;
        }
        
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            border-bottom: 2px solid #4f46e5;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid #4f46e5;
            border-radius: 6px;
            padding: 5px 10px;
            font-size: 12px;
            z-index: 100;
            display: none;
        }
        
        .lru-counter {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #4f46e5;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .fifo-position {
            position: absolute;
            bottom: -8px;
            right: -8px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .comparison-view {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        @media (max-width: 768px) {
            .comparison-view {
                grid-template-columns: 1fr;
            }
        }
        
        .bookmark-btn {
            background: #1e293b;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            margin-left: 10px;
        }
        
        .bookmarks-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            padding: 10px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
        }
        
        .step-details {
            margin-top: 10px;
            padding: 8px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- Cyberpunk Background -->
    <div class="cyber-bg">
        <div class="cyber-grid"></div>
        <div class="cyber-scanlines"></div>
    </div>
    
    <!-- Theme Toggle (New) -->
    <div class="theme-toggle" id="themeToggle">🌙</div>

    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center mb-8 text-white">Ultimate Page Replacement Simulator</h1>
        
        <!-- Controls -->
        <div class="sim-container p-6 rounded-lg mb-6">
            <div class="grid md:grid-cols-4 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium mb-1">Algorithm</label>
                    <div class="flex items-center">
                        <select id="algorithm" class="w-full p-2 border rounded bg-gray-800 text-white">
                            <option value="fifo">FIFO</option>
                            <option value="lru">LRU</option>
                            <option value="optimal">Optimal</option>
                            <option value="clock">Clock</option>
                            <option value="nfu">NFU (New)</option>
                            <option value="secondChance">Second Chance (New)</option>
                            <option value="workingSet">Working Set (New)</option>
                        </select>
                        <span class="help-icon ml-2" 
                              onmouseover="showAlgorithmGif('fifo')" 
                              onmouseout="hideGifTooltip()"></span>
                        <div class="gif-tooltip" id="fifoGif"></div>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Page Sequence</label>
                    <div class="flex">
                        <input id="pageSequence" type="text" placeholder="e.g., 1,2,3,4,1,2" class="flex-1 p-2 border rounded bg-gray-800 text-white">
                        <select id="presets" class="ml-2 p-2 bg-gray-800 text-white rounded">
                            <option value="">Custom</option>
                            <option value="1,2,3,4,1,2,5,1,2,3,4,5">Common Sequence</option>
                            <option value="1,2,3,4,5,1,2,3,4,5">Optimal Demo</option>
                            <option value="1,2,3,4,1,2,5,1,2,3,4,5,6,7,8">FIFO vs LRU</option>
                            <option value="1,2,3,4,1,5,3,1,2,4,5">Belady's Anomaly</option>
                            <option value="1,2,3,4,5,6,7,8,7,6,5,4,3,2,1">Locality of Reference</option>
                            <option value="1,2,3,1,4,2,5,1,2,3,6,7,8,7,8,9,7,8,9,1,2,3,4,5">Long Sequence</option>
                        </select>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Frame Count (1-5)</label>
                    <input id="frameCount" type="number" min="1" max="5" value="3" class="w-full p-2 border rounded bg-gray-800 text-white">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Speed</label>
                    <select id="speed" class="w-full p-2 border rounded bg-gray-800 text-white">
                        <option value="1000">Slow</option>
                        <option value="500" selected>Normal</option>
                        <option value="200">Fast</option>
                    </select>
                </div>
            </div>
            
            <div class="flex flex-wrap gap-2 justify-center mb-4">
                <button id="btnRandom" class="px-4 py-2 bg-gray-700 rounded hover:bg-gray-600 text-white">Random Sequence</button>
                <button id="btnStart" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Start</button>
                <button id="btnStep" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">Step</button>
                <button id="btnPause" class="px-4 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700">Pause</button>
                <button id="btnReset" class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">Reset</button>
                <button id="soundToggle" class="px-4 py-2 bg-gray-700 rounded hover:bg-gray-600 text-white">🔊 Sound On</button>
                <button id="exportBtn" class="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700">📷 Export</button>
                <button id="compareBtn" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">🔄 Compare</button>
                <button id="helpBtn" class="px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-600">❓ Tutorial</button>
            </div>
            
            <div class="flex flex-wrap gap-2 justify-center">
                <button id="saveStateBtn" class="px-4 py-2 bg-teal-600 text-white rounded hover:bg-teal-700">💾 Save State</button>
                <button id="loadStateBtn" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">📂 Load State</button>
                <button id="bookmarkBtn" class="px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-600">🔖 Bookmark</button>
                <button id="showDetailsBtn" class="px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-600">ℹ️ Show Details</button>
            </div>
        </div>
        
        <!-- Visualization -->
        <div class="sim-container p-6 rounded-lg mb-6">
            <div class="flex justify-between mb-4">
                <h2 class="text-xl font-semibold">Visualization</h2>
                <div class="flex items-center">
                    <span class="text-sm mr-2">View Mode:</span>
                    <div class="bg-gray-800 rounded-lg p-1 flex">
                        <button id="viewModeStandard" class="px-3 py-1 rounded-md bg-gray-700 text-white">Standard</button>
                        <button id="viewModeDetailed" class="px-3 py-1 rounded-md text-gray-300">Detailed</button>
                        <button id="viewModeCompare" class="px-3 py-1 rounded-md text-gray-300">Compare</button>
                    </div>
                </div>
            </div>
            
            <!-- Standard View -->
            <div id="standardView">
                <div class="flex justify-center mb-4">
                    <div id="memoryFrames" class="flex gap-4"></div>
                </div>
                <div class="flex justify-center">
                    <div id="pageSequenceDisplay" class="flex flex-wrap gap-2 justify-center max-w-2xl"></div>
                </div>
            </div>
            
            <!-- Detailed View (New) -->
            <div id="detailedView" class="hidden">
                <div class="flex md:flex-row flex-col">
                    <div class="flex-1">
                        <h3 class="text-lg font-semibold mb-2">Memory Frames</h3>
                        <div id="detailedMemoryFrames" class="flex gap-4 mb-4"></div>
                        
                        <div id="algorithmAnimation" class="algorithm-animation">
                            <!-- Animation for the specific algorithm will be rendered here -->
                        </div>
                        
                        <div id="stepDetails" class="step-details hidden">
                            <h4 class="font-semibold mb-1">Step Details</h4>
                            <div id="stepDetailsContent"></div>
                        </div>
                    </div>
                    
                    <div class="flex-1 md:ml-4 mt-4 md:mt-0">
                        <h3 class="text-lg font-semibold mb-2">Page Sequence</h3>
                        <div id="detailedPageSequence" class="flex flex-wrap gap-2 max-w-2xl"></div>
                        
                        <div class="mt-4">
                            <h4 class="font-semibold mb-1">Algorithm State</h4>
                            <div id="algorithmState" class="bg-gray-800 bg-opacity-50 p-2 rounded text-sm"></div>
                        </div>
                        
                        <div class="mt-4">
                            <h4 class="font-semibold mb-1">Bookmarks</h4>
                            <div id="bookmarksList" class="bookmarks-list hidden">
                                <p class="text-gray-400">No bookmarks yet.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Comparison View (New) -->
            <div id="comparisonView" class="hidden">
                <div class="comparison-view">
                    <!-- FIFO -->
                    <div class="sim-container p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-2">FIFO</h3>
                        <div id="fifoFrames" class="flex gap-2 mb-2"></div>
                        <div class="text-sm">
                            <div>Faults: <span id="fifoFaults">0</span></div>
                            <div>Hit Rate: <span id="fifoHitRate">0%</span></div>
                        </div>
                    </div>
                    
                    <!-- LRU -->
                    <div class="sim-container p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-2">LRU</h3>
                        <div id="lruFrames" class="flex gap-2 mb-2"></div>
                        <div class="text-sm">
                            <div>Faults: <span id="lruFaults">0</span></div>
                            <div>Hit Rate: <span id="lruHitRate">0%</span></div>
                        </div>
                    </div>
                    
                    <!-- Optimal -->
                    <div class="sim-container p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-2">Optimal</h3>
                        <div id="optimalFrames" class="flex gap-2 mb-2"></div>
                        <div class="text-sm">
                            <div>Faults: <span id="optimalFaults">0</span></div>
                            <div>Hit Rate: <span id="optimalHitRate">0%</span></div>
                        </div>
                    </div>
                    
                    <!-- Clock -->
                    <div class="sim-container p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-2">Clock</h3>
                        <div id="clockFrames" class="flex gap-2 mb-2"></div>
                        <div class="text-sm">
                            <div>Faults: <span id="clockFaults">0</span></div>
                            <div>Hit Rate: <span id="clockHitRate">0%</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-4">
                    <h3 class="text-lg font-semibold mb-2">Comparison Chart</h3>
                    <canvas id="comparisonChart" height="200"></canvas>
                </div>
            </div>
            
            <!-- Live Chart -->
            <div id="chartContainer">
                <canvas id="statsChart"></canvas>
            </div>
        </div>
        
        <!-- Stats -->
        <div class="grid md:grid-cols-3 gap-6 mb-6">
            <div class="sim-container p-6 rounded-lg">
                <h3 class="text-lg font-semibold mb-2">Statistics</h3>
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span>Page Faults:</span>
                        <span id="faultCount" class="font-bold">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Page Hits:</span>
                        <span id="hitCount" class="font-bold">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Hit Ratio:</span>
                        <span id="hitRatio" class="font-bold">0%</span>
                    </div>
                    <!-- New metrics -->
                    <div class="flex justify-between">
                        <span>Fault Rate:</span>
                        <span id="faultRate" class="font-bold">0%</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Average Access Time:</span>
                        <span id="avgAccessTime" class="font-bold">0ms</span>
                    </div>
                </div>
            </div>
            
            <div class="sim-container p-6 rounded-lg">
                <h3 class="text-lg font-semibold mb-2">Algorithm Info</h3>
                <p id="algorithmInfo" class="text-sm">
                    Select an algorithm to see its description.
                </p>
                
                <!-- New advanced info button -->
                <button id="advancedInfoBtn" class="mt-2 text-sm px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-white">
                    Show Advanced Info
                </button>
                
                <div id="algorithmDetails" class="algorithm-details">
                    <div class="tab-container">
                        <div class="tab active" data-tab="description">Description</div>
                        <div class="tab" data-tab="pros">Pros</div>
                        <div class="tab" data-tab="cons">Cons</div>
                        <div class="tab" data-tab="example">Example</div>
                    </div>
                    
                    <div class="tab-content active" data-content="description">
                        <!-- Algorithm description details will go here -->
                    </div>
                    <div class="tab-content" data-content="pros">
                        <!-- Algorithm pros will go here -->
                    </div>
                    <div class="tab-content" data-content="cons">
                        <!-- Algorithm cons will go here -->
                    </div>
                    <div class="tab-content" data-content="example">
                        <!-- Algorithm example will go here -->
                    </div>
                </div>
            </div>
            
            <div class="sim-container p-6 rounded-lg">
                <h3 class="text-lg font-semibold mb-2">Execution Log</h3>
                <div id="executionLog" class="text-sm h-32 overflow-y-auto bg-gray-800 bg-opacity-50 p-2 rounded"></div>
                
                <!-- Log filter options -->
                <div class="flex mt-2 gap-2">
                    <button id="filterAll" class="text-xs px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-white">All</button>
                    <button id="filterFaults" class="text-xs px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-white">Faults</button>
                    <button id="filterHits" class="text-xs px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-white">Hits</button>
                    <button id="clearLog" class="text-xs px-2 py-1 bg-red-700 rounded hover:bg-red-600 text-white">Clear</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Tutorial Modal (New) -->
    <div class="modal" id="tutorialModal">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-4">Page Replacement Simulator Tutorial</h2>
            <p class="mb-4">Welcome to the Ultimate Page Replacement Simulator! This tool helps you understand how different page replacement algorithms work in operating systems.</p>
            
            <div class="space-y-4" id="tutorialContent">
                <!-- Tutorial steps will be populated here -->
            </div>
            
            <div class="flex justify-between mt-6">
                <button id="tutorialPrev" class="px-4 py-2 bg-gray-700 rounded hover:bg-gray-600 text-white">Previous</button>
                <span id="tutorialStep">Step 1/6</span>
                <button id="tutorialNext" class="px-4 py-2 bg-blue-600 rounded hover:bg-blue-700 text-white">Next</button>
            </div>
            
            <button id="tutorialClose" class="absolute top-4 right-4 text-gray-400 hover:text-white">✕</button>
        </div>
    </div>
    
    <!-- Algorithm Details Modal (New) -->
    <div class="modal" id="algorithmModal">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-4" id="algorithmModalTitle">Algorithm Details</h2>
            
            <div class="tab-container">
                <div class="tab active" data-modal-tab="description">Description</div>
                <div class="tab" data-modal-tab="visualization">Visualization</div>
                <div class="tab" data-modal-tab="implementation">Implementation</div>
                <div class="tab" data-modal-tab="comparison">Comparison</div>
            </div>
            
            <div class="tab-content active" data-modal-content="description">
                <div id="algorithmModalDesc"></div>
            </div>
            
            <div class="tab-content" data-modal-content="visualization">
                <div id="algorithmModalViz" class="h-60 bg-gray-800 rounded-lg my-4 p-4"></div>
            </div>
            
            <div class="tab-content" data-modal-content="implementation">
                <pre id="algorithmModalCode" class="bg-gray-800 p-4 rounded-lg my-4 overflow-x-auto text-sm"></pre>
            </div>
            
            <div class="tab-content" data-modal-content="comparison">
                <table class="w-full mt-4 text-sm">
                    <thead>
                        <tr class="border-b border-gray-700">
                            <th class="text-left p-2">Algorithm</th>
                            <th class="text-left p-2">Complexity</th>
                            <th class="text-left p-2">Efficiency</th>
                            <th class="text-left p-2">Implementation</th>
                        </tr>
                    </thead>
                    <tbody id="algorithmComparisonTable">
                        <!-- Comparison data will go here -->
                    </tbody>
                </table>
            </div>
            
            <button id="algorithmModalClose" class="absolute top-4 right-4 text-gray-400 hover:text-white">✕</button>
        </div>
    </div>
    
    <!-- Compare Results Modal (New) -->
    <div class="modal" id="compareModal">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-4">Algorithm Comparison Results</h2>
            
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                <div class="p-3 bg-gray-800 rounded-lg">
                    <h3 class="text-sm font-medium mb-1">FIFO</h3>
                    <div class="text-lg font-bold" id="modalFifoFaults">0</div>
                    <div class="text-xs text-gray-400">Page Faults</div>
                    <div class="text-sm mt-2" id="modalFifoHitRate">0%</div>
                    <div class="text-xs text-gray-400">Hit Rate</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <h3 class="text-sm font-medium mb-1">LRU</h3>
                    <div class="text-lg font-bold" id="modalLruFaults">0</div>
                    <div class="text-xs text-gray-400">Page Faults</div>
                    <div class="text-sm mt-2" id="modalLruHitRate">0%</div>
                    <div class="text-xs text-gray-400">Hit Rate</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <h3 class="text-sm font-medium mb-1">Optimal</h3>
                    <div class="text-lg font-bold" id="modalOptimalFaults">0</div>
                    <div class="text-xs text-gray-400">Page Faults</div>
                    <div class="text-sm mt-2" id="modalOptimalHitRate">0%</div>
                    <div class="text-xs text-gray-400">Hit Rate</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <h3 class="text-sm font-medium mb-1">Clock</h3>
                    <div class="text-lg font-bold" id="modalClockFaults">0</div>
                    <div class="text-xs text-gray-400">Page Faults</div>
                    <div class="text-sm mt-2" id="modalClockHitRate">0%</div>
                    <div class="text-xs text-gray-400">Hit Rate</div>
                </div>
            </div>
            
            <div>
                <h3 class="text-lg font-semibold mb-2">Performance Comparison</h3>
                <canvas id="modalComparisonChart" height="200"></canvas>
            </div>
            
            <div class="mt-4">
                <h3 class="text-lg font-semibold mb-2">Analysis</h3>
                <p id="comparisonAnalysis" class="text-sm">
                    Run the comparison to see which algorithm performs best for your page sequence.
                </p>
            </div>
            
            <button id="compareModalClose" class="absolute top-4 right-4 text-gray-400 hover:text-white">✕</button>
        </div>
    </div>
    
    <!-- Export Preview Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-4">Export Visualization</h2>
            <div id="exportPreview" class="mb-4 bg-gray-800 p-4 rounded-lg overflow-auto max-h-96"></div>
            <div class="flex justify-between">
                <button id="cancelExport" class="px-4 py-2 bg-gray-700 rounded hover:bg-gray-600 text-white">Cancel</button>
                <button id="confirmExport" class="px-4 py-2 bg-green-600 rounded hover:bg-green-700 text-white">Download</button>
            </div>
        </div>
    </div>
    
    <!-- Sound Effects (hidden) -->
    <audio id="hitSound" src="data:audio/wav;base64,UklGRjQGAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YTAG' + Array(100).join('AAAA')"></audio>
    <audio id="faultSound" src="data:audio/wav;base64,UklGRjQGAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YTAG' + Array(100).join('AAAA')"></audio>
    
    <script>
        // Main variables
        let pageSequence = [];
        let frames = [];
        let frameCount = 3;
        let currentPageIndex = -1;
        let stats = { hits: 0, faults: 0 };
        let algorithm = "fifo";
        let running = false;
        let timer = null;
        let speed = 500;
        let soundEnabled = true;
        let algorithm_state = {
            fifo: { pointer: 0 },
            lru: { counter: 0, timestamps: {} },
            clock: { pointer: 0, referenced: {} },
            nfu: { counters: {} },
            secondChance: { pointer: 0, secondChance: {} },
            workingSet: { timestamps: {}, windowSize: 3 }
        };
        
        // Algorithm info
        const algorithmInfo = {
            fifo: {
                description: "First-In-First-Out (FIFO) replaces the page that has been in memory the longest, regardless of usage.",
                pros: ["Simple to implement", "Low overhead", "No need to track page usage"],
                cons: ["Does not consider page usage frequency", "Can lead to Belady's Anomaly", "May remove frequently used pages"],
                example: "For the sequence [1,2,3,4,1,2] with 3 frames, FIFO would replace page 1 when page 4 arrives, even though page 1 will be needed soon.",
                code: `function fifo(page) {
    if (frames.includes(page)) {
        return "hit";
    }
    if (frames.length < frameCount) {
        frames.push(page);
        return "fault";
    }
    frames[algorithm_state.fifo.pointer] = page;
    algorithm_state.fifo.pointer = (algorithm_state.fifo.pointer + 1) % frameCount;
    return "fault";
}`
            },
            lru: {
                description: "Least Recently Used (LRU) replaces the page that hasn't been accessed for the longest time.",
                pros: ["Better real-world performance than FIFO", "Accounts for temporal locality", "Adapts to changing access patterns"],
                cons: ["Higher overhead due to timestamp tracking", "Difficult to implement efficiently in hardware", "Can still perform poorly with certain access patterns"],
                example: "For the sequence [1,2,3,4,1,2] with 3 frames, LRU would replace page 3 when page 4 arrives because pages 1 and 2 were accessed more recently.",
                code: `function lru(page) {
    algorithm_state.lru.counter++;
    if (frames.includes(page)) {
        algorithm_state.lru.timestamps[page] = algorithm_state.lru.counter;
        return "hit";
    }
    if (frames.length < frameCount) {
        frames.push(page);
        algorithm_state.lru.timestamps[page] = algorithm_state.lru.counter;
        return "fault";
    }
    let leastRecentPage = frames[0];
    for (const frame of frames) {
        if (algorithm_state.lru.timestamps[frame] < 
            algorithm_state.lru.timestamps[leastRecentPage]) {
            leastRecentPage = frame;
        }
    }
    const index = frames.indexOf(leastRecentPage);
    frames[index] = page;
    algorithm_state.lru.timestamps[page] = algorithm_state.lru.counter;
    return "fault";
}`
            },
            optimal: {
                description: "Optimal (Belady's) algorithm replaces the page that will not be used for the longest time in the future.",
                pros: ["Theoretically optimal - lowest possible page fault rate", "Useful as a benchmark", "Immune to Belady's Anomaly"],
                cons: ["Requires knowledge of future page references", "Impractical for real systems", "Computationally intensive to simulate"],
                example: "For the sequence [1,2,3,4,1,2] with 3 frames, Optimal would replace page 3 when page 4 arrives because pages 1 and 2 will be needed sooner than page 3.",
                code: `function optimal(page) {
    if (frames.includes(page)) {
        return "hit";
    }
    if (frames.length < frameCount) {
        frames.push(page);
        return "fault";
    }
    
    // Find page that will not be used for the longest time
    let farthestPage = -1;
    let farthestDistance = -1;
    
    for (const frame of frames) {
        let nextUseIndex = pageSequence.findIndex(
            (p, i) => i > currentPageIndex && p === frame
        );
        
        if (nextUseIndex === -1) {
            // Page never used again, replace it
            farthestPage = frame;
            break;
        }
        
        const distance = nextUseIndex - currentPageIndex;
        if (distance > farthestDistance) {
            farthestDistance = distance;
            farthestPage = frame;
        }
    }
    
    const index = frames.indexOf(farthestPage);
    frames[index] = page;
    return "fault";
}`
            },
            clock: {
                description: "Clock algorithm uses a circular buffer and a reference bit to approximate LRU with lower overhead.",
                pros: ["Lower overhead than LRU", "Reasonable performance", "Easier hardware implementation"],
                cons: ["Not as effective as LRU", "Extra space for reference bits", "Still needs some tracking overhead"],
                example: "When a page fault occurs, the algorithm moves a clock hand and checks each page's reference bit. If the bit is 0, replace the page; if 1, set to 0 and move on.",
                code: `function clock(page) {
    if (frames.includes(page)) {
        algorithm_state.clock.referenced[page] = 1;
        return "hit";
    }
    
    if (frames.length < frameCount) {
        frames.push(page);
        algorithm_state.clock.referenced[page] = 1;
        return "fault";
    }
    
    // Find a page to replace using the clock algorithm
    while (true) {
        const current = frames[algorithm_state.clock.pointer];
        if (algorithm_state.clock.referenced[current] === 0) {
            frames[algorithm_state.clock.pointer] = page;
            algorithm_state.clock.referenced[page] = 1;
            algorithm_state.clock.pointer = 
                (algorithm_state.clock.pointer + 1) % frameCount;
            return "fault";
        }
        algorithm_state.clock.referenced[current] = 0;
        algorithm_state.clock.pointer = 
            (algorithm_state.clock.pointer + 1) % frameCount;
    }
}`
            },
            nfu: {
                description: "Not Frequently Used (NFU) tracks how often each page is referenced and replaces the least frequently used.",
                pros: ["Accounts for frequency of use", "Simple counters implementation", "Good for repeated access patterns"],
                cons: ["Doesn't account for temporal locality", "Old pages can accumulate high counts", "Static access patterns cause inefficiency"],
                example: "Each page has a counter that increases when it's accessed. The page with the lowest counter is replaced on a fault.",
                code: `function nfu(page) {
    if (frames.includes(page)) {
        algorithm_state.nfu.counters[page]++;
        return "hit";
    }
    
    if (frames.length < frameCount) {
        frames.push(page);
        algorithm_state.nfu.counters[page] = 1;
        return "fault";
    }
    
    let leastFrequent = frames[0];
    for (const frame of frames) {
        if (algorithm_state.nfu.counters[frame] < 
            algorithm_state.nfu.counters[leastFrequent]) {
            leastFrequent = frame;
        }
    }
    
    const index = frames.indexOf(leastFrequent);
    frames[index] = page;
    algorithm_state.nfu.counters[page] = 1;
    return "fault";
}`
            },
            secondChance: {
                description: "Second Chance is an enhancement of FIFO that gives pages a second chance before replacement.",
                pros: ["Better than FIFO", "Less overhead than LRU", "Simple to implement"],
                cons: ["Not as effective as full LRU", "Can still perform poorly with certain access patterns"],
                example: "Works like FIFO but before replacing a page, checks its reference bit. If 1, sets to 0 and moves on; if 0, replaces it.",
                code: `function secondChance(page) {
    if (frames.includes(page)) {
        algorithm_state.secondChance.secondChance[page] = 1;
        return "hit";
    }
    
    if (frames.length < frameCount) {
        frames.push(page);
        algorithm_state.secondChance.secondChance[page] = 0;
        return "fault";
    }
    
    while (true) {
        const current = frames[algorithm_state.secondChance.pointer];
        if (algorithm_state.secondChance.secondChance[current] === 0) {
            frames[algorithm_state.secondChance.pointer] = page;
            algorithm_state.secondChance.secondChance[page] = 0;
            algorithm_state.secondChance.pointer = 
                (algorithm_state.secondChance.pointer + 1) % frameCount;
            return "fault";
        }
        algorithm_state.secondChance.secondChance[current] = 0;
        algorithm_state.secondChance.pointer = 
            (algorithm_state.secondChance.pointer + 1) % frameCount;
    }
}`
            },
            workingSet: {
                description: "Working Set tracks pages used within a recent time window, aiming to keep the working set in memory.",
                pros: ["Accounts for temporal locality", "Adapts to program phases", "Good for real-world workloads"],
                cons: ["High overhead to track timestamps", "Window size is a critical parameter", "Difficult to implement in hardware"],
                example: "The working set is defined by pages accessed in the last T time units. Pages not in the working set are candidates for replacement.",
                code: `function workingSet(page) {
    const currentTime = ++algorithm_state.workingSet.timestamps.time;
    
    if (frames.includes(page)) {
        algorithm_state.workingSet.timestamps[page] = currentTime;
        return "hit";
    }
    
    if (frames.length < frameCount) {
        frames.push(page);
        algorithm_state.workingSet.timestamps[page] = currentTime;
        return "fault";
    }
    
    // Find the page that's been outside the working set for longest
    let oldestPage = frames[0];
    let oldestTime = algorithm_state.workingSet.timestamps[oldestPage];
    
    for (const frame of frames) {
        const timestamp = algorithm_state.workingSet.timestamps[frame];
        if (timestamp < oldestTime) {
            oldestTime = timestamp;
            oldestPage = frame;
        }
    }
    
    const index = frames.indexOf(oldestPage);
    frames[index] = page;
    algorithm_state.workingSet.timestamps[page] = currentTime;
    return "fault";
}`
            }
        };
        
        // DOM elements
        const memoryFramesEl = document.getElementById('memoryFrames');
        const pageSequenceEl = document.getElementById('pageSequenceDisplay');
        const faultCountEl = document.getElementById('faultCount');
        const hitCountEl = document.getElementById('hitCount');
        const hitRatioEl = document.getElementById('hitRatio');
        const faultRateEl = document.getElementById('faultRate');
        const avgAccessTimeEl = document.getElementById('avgAccessTime');
        const algorithmInfoEl = document.getElementById('algorithmInfo');
        const executionLogEl = document.getElementById('executionLog');
        const algorithmDetailsEl = document.getElementById('algorithmDetails');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initUI();
            setupEventListeners();
            updateAlgorithmInfo();
            resetSimulation();
        
            // ADD THIS RIGHT HERE ▼ (Point 5)
            document.getElementById('advancedInfoBtn').addEventListener('click', function() {
                const info = algorithmInfo[algorithm] || algorithmInfo.fifo;
                document.getElementById('algorithmModalTitle').textContent = `${algorithm.toUpperCase()} Algorithm Details`;
                document.getElementById('algorithmModalDesc').innerHTML = `<p>${info.description}</p>`;
                document.getElementById('algorithmModalCode').textContent = info.code;
                document.getElementById('algorithmModal').style.display = 'flex';
            });
            // ▲ Add the above code block here
        
            if (!localStorage.getItem('tutorialShown')) {
                showTutorial();
                localStorage.setItem('tutorialShown', 'true');
            }
        });
        
        // Initialize UI components
        function initUI() {
            // Initialize chart
            const ctx = document.getElementById('statsChart').getContext('2d');
            window.statsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Hit Ratio',
                        data: [],
                        borderColor: '#10b981',
                        tension: 0.1
                    }, {
                        label: 'Fault Ratio',
                        data: [],
                        borderColor: '#ef4444',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
            
            // Initialize comparison chart
            const compCtx = document.getElementById('comparisonChart').getContext('2d');
            window.comparisonChart = new Chart(compCtx, {
                type: 'bar',
                data: {
                    labels: ['FIFO', 'LRU', 'Optimal', 'Clock', 'NFU', 'Second Chance', 'Working Set'],
                    datasets: [{
                        label: 'Page Faults',
                        data: [0, 0, 0, 0, 0, 0, 0],
                        backgroundColor: [
                            'rgba(239, 68, 68, 0.7)',
                            'rgba(16, 185, 129, 0.7)',
                            'rgba(79, 70, 229, 0.7)',
                            'rgba(245, 158, 11, 0.7)',
                            'rgba(59, 130, 246, 0.7)',
                            'rgba(139, 92, 246, 0.7)',
                            'rgba(20, 184, 166, 0.7)'
                        ]
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true
                }
            });
            
            // Initialize modal comparison chart
            const modalCompCtx = document.getElementById('modalComparisonChart').getContext('2d');
            window.modalComparisonChart = new Chart(modalCompCtx, {
                type: 'bar',
                data: {
                    labels: ['FIFO', 'LRU', 'Optimal', 'Clock'],
                    datasets: [{
                        label: 'Page Faults',
                        data: [0, 0, 0, 0],
                        backgroundColor: [
                            'rgba(239, 68, 68, 0.7)',
                            'rgba(16, 185, 129, 0.7)',
                            'rgba(79, 70, 229, 0.7)',
                            'rgba(245, 158, 11, 0.7)'
                        ]
                    }, {
                        label: 'Hit Rate (%)',
                        data: [0, 0, 0, 0],
                        backgroundColor: [
                            'rgba(239, 68, 68, 0.4)',
                            'rgba(16, 185, 129, 0.4)',
                            'rgba(79, 70, 229, 0.4)',
                            'rgba(245, 158, 11, 0.4)'
                        ]
                    }]
                },
                options: {
                    responsive: true
                }
            });
            
            // Set up tutorial content
            setupTutorial();
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Button event listeners
            document.getElementById('btnRandom').addEventListener('click', generateRandomSequence);
            document.getElementById('btnStart').addEventListener('click', startSimulation);
            document.getElementById('btnStep').addEventListener('click', stepSimulation);
            document.getElementById('btnPause').addEventListener('click', pauseSimulation);
            document.getElementById('btnReset').addEventListener('click', resetSimulation);
            document.getElementById('soundToggle').addEventListener('click', toggleSound);
            document.getElementById('exportBtn').addEventListener('click', exportVisualization);
            document.getElementById('compareBtn').addEventListener('click', showComparisonView);
            document.getElementById('helpBtn').addEventListener('click', showTutorial);
            document.getElementById('advancedInfoBtn').addEventListener('click', toggleAlgorithmDetails);
            document.getElementById('saveStateBtn').addEventListener('click', saveState);
            document.getElementById('loadStateBtn').addEventListener('click', loadState);
            document.getElementById('bookmarkBtn').addEventListener('click', addBookmark);
            document.getElementById('showDetailsBtn').addEventListener('click', toggleStepDetails);
            
            // View mode buttons
            document.getElementById('viewModeStandard').addEventListener('click', () => setViewMode('standard'));
            document.getElementById('viewModeDetailed').addEventListener('click', () => setViewMode('detailed'));
            document.getElementById('viewModeCompare').addEventListener('click', () => setViewMode('compare'));
            
            // Log filter buttons
            document.getElementById('filterAll').addEventListener('click', () => filterLog('all'));
            document.getElementById('filterFaults').addEventListener('click', () => filterLog('faults'));
            document.getElementById('filterHits').addEventListener('click', () => filterLog('hits'));
            document.getElementById('clearLog').addEventListener('click', clearLog);
            
            // Tutorial modal buttons
            document.getElementById('tutorialNext').addEventListener('click', tutorialNext);
            document.getElementById('tutorialPrev').addEventListener('click', tutorialPrev);
            document.getElementById('tutorialClose').addEventListener('click', closeTutorial);
            
            // Compare modal button
            document.getElementById('compareModalClose').addEventListener('click', closeCompareModal);
            
            // Export modal buttons
            document.getElementById('cancelExport').addEventListener('click', closeExportModal);
            document.getElementById('confirmExport').addEventListener('click', downloadExport);
            
            // Algorithm modal button
            document.getElementById('algorithmModalClose').addEventListener('click', closeAlgorithmModal);
            
            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            
            // Preset dropdown
            document.getElementById('presets').addEventListener('change', function() {
                if (this.value) {
                    document.getElementById('pageSequence').value = this.value;
                }
            });
            
            // Algorithm change
            document.getElementById('algorithm').addEventListener('change', function() {
                algorithm = this.value;
                updateAlgorithmInfo();
            });
            
            // Tab functionality for algorithm details
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabSet = this.getAttribute('data-tab') ? 'data-tab' : 'data-modal-tab';
                    const contentSet = tabSet === 'data-tab' ? 'data-content' : 'data-modal-content';
                    
                    // Remove active class from all tabs in this set
                    document.querySelectorAll(`[${tabSet}]`).forEach(t => {
                        t.classList.remove('active');
                    });
                    
                    // Add active class to clicked tab
                    this.classList.add('active');
                    
                    // Hide all tab content
                    document.querySelectorAll(`[${contentSet}]`).forEach(c => {
                        c.classList.remove('active');
                    });
                    
                    // Show the corresponding content
                    const contentId = this.getAttribute(tabSet);
                    document.querySelector(`[${contentSet}="${contentId}"]`).classList.add('active');
                });
            });
            document.querySelectorAll('[data-modal-tab]').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabSet = 'data-modal-tab';
                    const contentSet = 'data-modal-content';
                    
                    document.querySelectorAll(`[${tabSet}]`).forEach(t => {
                        t.classList.remove('active');
                    });
                    
                    this.classList.add('active');
                    
                    document.querySelectorAll(`[${contentSet}]`).forEach(c => {
                        c.classList.remove('active');
                    });
                    
                    const contentId = this.getAttribute(tabSet);
                    document.querySelector(`[${contentSet}="${contentId}"]`).classList.add('active');
                });
            });
        }
        
        // Function to generate a random page sequence
        function generateRandomSequence() {
            const length = Math.floor(Math.random() * 10) + 10; // 10-20 pages
            const maxPage = 8;
            let sequence = [];
            
            // Generate with some locality of reference
            for (let i = 0; i < length; i++) {
                // 70% chance to reference a recently used page
                if (i > 3 && Math.random() < 0.7) {
                    const recentIndex = Math.floor(Math.random() * 3);
                    sequence.push(sequence[i - 1 - recentIndex]);
                } else {
                    sequence.push(Math.floor(Math.random() * maxPage) + 1);
                }
            }
            
            document.getElementById('pageSequence').value = sequence.join(',');
        }
        
        // Start the simulation
        function startSimulation() {
            if (running) return;
            
            // Parse the page sequence
            const input = document.getElementById('pageSequence').value;
            pageSequence = input.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
            
            if (pageSequence.length === 0) {
                addLog("Error: Please enter a valid page sequence", "error");
                return;
            }
            
            // Get frame count
            frameCount = parseInt(document.getElementById('frameCount').value);
            if (isNaN(frameCount) || frameCount < 1 || frameCount > 5) {
                addLog("Error: Frame count must be between 1 and 5", "error");
                return;
            }
            
            // Get speed
            speed = parseInt(document.getElementById('speed').value);
            
            // Reset simulation state
            resetSimulationState();
            
            // Update UI
            updatePageSequenceDisplay();
            updateFramesDisplay();
            
            // Start the timer
            running = true;
            timer = setInterval(stepSimulation, speed);
            
            // Show chart
            document.getElementById('chartContainer').style.display = 'block';
        }
        
        // Reset the simulation state without updating UI
        function resetSimulationState() {
            frames = [];
            currentPageIndex = -1;
            stats = { hits: 0, faults: 0 };
            
            // Reset algorithm-specific state
            algorithm_state = {
                fifo: { pointer: 0 },
                lru: { counter: 0, timestamps: {} },
                clock: { pointer: 0, referenced: {} },
                nfu: { counters: {} },
                secondChance: { pointer: 0, secondChance: {} },
                workingSet: { timestamps: { time: 0 }, windowSize: 3 }
            };
        }
        
        // Step through the simulation
        function stepSimulation() {
            if (currentPageIndex >= pageSequence.length - 1) {
                pauseSimulation();
                addLog("Simulation complete", "info");
                return;
            }
            
            currentPageIndex++;
            const page = pageSequence[currentPageIndex];
            let result;
            
            // Apply the selected algorithm
            switch (algorithm) {
                case "fifo": result = fifo(page); break;
                case "lru": result = lru(page); break;
                case "optimal": result = optimal(page); break;
                case "clock": result = clock(page); break;
                case "nfu": result = nfu(page); break;
                case "secondChance": result = secondChance(page); break;
                case "workingSet": result = workingSet(page); break;
                default: result = fifo(page);
            }
            
            // Update stats
            if (result === "hit") {
                stats.hits++;
                if (soundEnabled) document.getElementById('hitSound').play();
            } else {
                stats.faults++;
                if (soundEnabled) document.getElementById('faultSound').play();
            }
            
            // Update UI
            updatePageSequenceDisplay();
            updateFramesDisplay();
            updateStats();
            addLog(`Page ${page}: ${result.toUpperCase()}`, result);
            updateCharts();
            updateStepDetails(page, result);
            
            // Update algorithm state display
            updateAlgorithmStateDisplay();
        }
        
        // Pause the simulation
        function pauseSimulation() {
            if (!running) return;
            clearInterval(timer);
            running = false;
        }
        
        // Reset the simulation
        function resetSimulation() {
            pauseSimulation();
            resetSimulationState();
            
            // Reset UI
            memoryFramesEl.innerHTML = "";
            pageSequenceEl.innerHTML = "";
            faultCountEl.textContent = "0";
            hitCountEl.textContent = "0";
            hitRatioEl.textContent = "0%";
            faultRateEl.textContent = "0%";
            avgAccessTimeEl.textContent = "0ms";
            clearLog();
            
            // Reset chart
            window.statsChart.data.labels = [];
            window.statsChart.data.datasets[0].data = [];
            window.statsChart.data.datasets[1].data = [];
            window.statsChart.update();
            
            // Setup page sequence display
            const input = document.getElementById('pageSequence').value;
            if (input) {
                pageSequence = input.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
                updatePageSequenceDisplay();
            }
        }
        
        // Update the page sequence display
        function updatePageSequenceDisplay() {
            pageSequenceEl.innerHTML = "";
            
            pageSequence.forEach((page, index) => {
                const div = document.createElement('div');
                div.classList.add('w-8', 'h-8', 'flex', 'items-center', 'justify-center', 'rounded');
                div.textContent = page;
                
                if (index === currentPageIndex) {
                    div.classList.add('current-page', 'frame-pulse');
                    
                    // If frame contains this page, it's a hit, otherwise a fault
                    if (frames.includes(page)) {
                        div.classList.add('page-hit');
                    } else {
                        div.classList.add('page-fault');
                    }
                } else {
                    div.classList.add('bg-gray-700');
                }
                
                pageSequenceEl.appendChild(div);
            });
            
            // Do the same for detailed view
            if (document.getElementById('detailedPageSequence')) {
                const detailedSeq = document.getElementById('detailedPageSequence');
                detailedSeq.innerHTML = "";
                
                pageSequence.forEach((page, index) => {
                    const div = document.createElement('div');
                    div.classList.add('w-8', 'h-8', 'flex', 'items-center', 'justify-center', 'rounded');
                    div.textContent = page;
                    
                    if (index === currentPageIndex) {
                        div.classList.add('current-page', 'frame-pulse');
                        
                        // If frame contains this page, it's a hit, otherwise a fault
                        if (frames.includes(page)) {
                            div.classList.add('page-hit');
                        } else {
                            div.classList.add('page-fault');
                        }
                    } else if (index < currentPageIndex) {
                        // For past pages, show if they were hits or faults
                        if (frames.includes(page)) {
                            div.classList.add('page-hit');
                        } else {
                            div.classList.add('page-fault');
                        }
                    } else {
                        // Future pages
                        div.classList.add('bg-gray-700');
                    }
                    
                    detailedSeq.appendChild(div);
                });
            }
        }
        
        // Update the memory frames display
        function updateFramesDisplay() {
            memoryFramesEl.innerHTML = "";
            
            // Create frame elements
            for (let i = 0; i < frameCount; i++) {
                const frame = document.createElement('div');
                frame.classList.add('w-12', 'h-12', 'flex', 'items-center', 'justify-center', 'rounded', 'bg-gray-800', 'border', 'border-gray-700');
                
                if (i < frames.length) {
                    frame.textContent = frames[i];
                    
                    // Add algorithm-specific decorations
                    if (algorithm === "lru") {
                        const counter = document.createElement('div');
                        counter.classList.add('lru-counter');
                        counter.textContent = algorithm_state.lru.timestamps[frames[i]] || 0;
                        frame.appendChild(counter);
                        frame.style.position = 'relative';
                    }
                    
                    if (algorithm === "fifo" && i === algorithm_state.fifo.pointer) {
                        const pointer = document.createElement('div');
                        pointer.classList.add('fifo-position');
                        pointer.textContent = 'F';
                        frame.appendChild(pointer);
                        frame.style.position = 'relative';
                    }
                    
                    if (algorithm === "clock" && i === algorithm_state.clock.pointer) {
                        const pointer = document.createElement('div');
                        pointer.classList.add('fifo-position');
                        pointer.textContent = 'C';
                        frame.appendChild(pointer);
                        frame.style.position = 'relative';
                    }
                }
                
                memoryFramesEl.appendChild(frame);
            }
            
            // Update detailed view if it exists
            if (document.getElementById('detailedMemoryFrames')) {
                const detailedFrames = document.getElementById('detailedMemoryFrames');
                detailedFrames.innerHTML = "";
                
                for (let i = 0; i < frameCount; i++) {
                    const frame = document.createElement('div');
                    frame.classList.add('w-16', 'h-16', 'flex', 'flex-col', 'items-center', 'justify-center', 'rounded', 'bg-gray-800', 'border', 'border-gray-700', 'p-2');
                    
                    if (i < frames.length) {
                        frame.innerHTML = `
                            <div class="text-lg font-bold">${frames[i]}</div>
                            <div class="text-xs mt-1 text-gray-400">
                                ${getFrameDetails(frames[i])}
                            </div>
                        `;
                        
                        // Highlight if this frame contains the current page
                        if (currentPageIndex >= 0 && frames[i] === pageSequence[currentPageIndex]) {
                            frame.classList.add('frame-pulse');
                        }
                    } else {
                        frame.textContent = "Empty";
                    }
                    
                    detailedFrames.appendChild(frame);
                }
            }
        }
        
        // Helper function to get frame details for detailed view
        function getFrameDetails(page) {
            switch (algorithm) {
                case "lru":
                    return `Last used: ${algorithm_state.lru.timestamps[page] || 'N/A'}`;
                case "fifo":
                    return `Loaded at: ${algorithm_state.fifo.pointer === frames.indexOf(page) ? 'Next to replace' : ''}`;
                case "clock":
                    return `Ref bit: ${algorithm_state.clock.referenced[page] || 0}`;
                case "nfu":
                    return `Count: ${algorithm_state.nfu.counters[page] || 0}`;
                case "secondChance":
                    return `Second chance: ${algorithm_state.secondChance.secondChance[page] || 0}`;
                case "workingSet":
                    return `Last used: ${algorithm_state.workingSet.timestamps[page] || 'N/A'}`;
                default:
                    return "";
            }
        }
            // Update statistics display
    function updateStats() {
        faultCountEl.textContent = stats.faults;
        hitCountEl.textContent = stats.hits;
        
        const total = stats.hits + stats.faults;
        const hitRatio = total > 0 ? Math.round((stats.hits / total) * 100) : 0;
        const faultRate = total > 0 ? Math.round((stats.faults / total) * 100) : 0;
        
        hitRatioEl.textContent = `${hitRatio}%`;
        faultRateEl.textContent = `${faultRate}%`;
        
        // Calculate average access time (simplified model)
        const avgTime = total > 0 ? Math.round((stats.hits * 10 + stats.faults * 100) / total) : 0;
        avgAccessTimeEl.textContent = `${avgTime}ms`;
    }

    // Update the charts with current data
    function updateCharts() {
        const total = stats.hits + stats.faults;
        const hitRatio = total > 0 ? Math.round((stats.hits / total) * 100) : 0;
        const faultRate = total > 0 ? Math.round((stats.faults / total) * 100) : 0;
        
        // Update main stats chart
        window.statsChart.data.labels.push(currentPageIndex + 1);
        window.statsChart.data.datasets[0].data.push(hitRatio);
        window.statsChart.data.datasets[1].data.push(faultRate);
        window.statsChart.update();
    }

    // Add a message to the execution log
    function addLog(message, type = "info") {
        const logEntry = document.createElement('div');
        logEntry.classList.add('mb-1');
        
        switch (type) {
            case "error":
                logEntry.classList.add('text-red-400');
                break;
            case "hit":
                logEntry.classList.add('text-green-400');
                break;
            case "fault":
                logEntry.classList.add('text-red-400');
                break;
            default:
                logEntry.classList.add('text-gray-400');
        }
        
        logEntry.textContent = `Step ${currentPageIndex + 1}: ${message}`;
        executionLogEl.appendChild(logEntry);
        executionLogEl.scrollTop = executionLogEl.scrollHeight;
    }

    // Filter the execution log
    function filterLog(filterType) {
        const entries = executionLogEl.querySelectorAll('div');
        entries.forEach(entry => {
            switch (filterType) {
                case "all":
                    entry.style.display = "block";
                    break;
                case "faults":
                    entry.style.display = entry.classList.contains('text-red-400') ? "block" : "none";
                    break;
                case "hits":
                    entry.style.display = entry.classList.contains('text-green-400') ? "block" : "none";
                    break;
            }
        });
    }

    // Clear the execution log
    function clearLog() {
        executionLogEl.innerHTML = "";
    }

    // Update algorithm information display
    function updateAlgorithmInfo() {
        const info = algorithmInfo[algorithm] || algorithmInfo.fifo;
        algorithmInfoEl.textContent = info.description;
        
        // Update the details tabs
        document.querySelector('[data-content="description"]').innerHTML = `<p>${info.description}</p>`;
        document.querySelector('[data-content="pros"]').innerHTML = 
            `<ul class="list-disc pl-5">${info.pros.map(pro => `<li>${pro}</li>`).join('')}</ul>`;
        document.querySelector('[data-content="cons"]').innerHTML = 
            `<ul class="list-disc pl-5">${info.cons.map(con => `<li>${con}</li>`).join('')}</ul>`;
        document.querySelector('[data-content="example"]').innerHTML = `<p>${info.example}</p>`;
        
        // Update modal content
        document.getElementById('algorithmModalDesc').innerHTML = `<p>${info.description}</p>`;
        document.getElementById('algorithmModalCode').textContent = info.code;
    }

    // Toggle algorithm details visibility
    function toggleAlgorithmDetails() {
        algorithmDetailsEl.style.display = algorithmDetailsEl.style.display === 'none' ? 'block' : 'none';
    }

    // Toggle sound effects
    function toggleSound() {
        soundEnabled = !soundEnabled;
        const btn = document.getElementById('soundToggle');
        btn.textContent = soundEnabled ? "🔊 Sound On" : "🔇 Sound Off";
    }

    // Set the view mode (standard, detailed, compare)
    function setViewMode(mode) {
        document.getElementById('standardView').style.display = mode === 'standard' ? 'block' : 'none';
        document.getElementById('detailedView').style.display = mode === 'detailed' ? 'block' : 'none';
        document.getElementById('comparisonView').style.display = mode === 'compare' ? 'block' : 'none';
        
        // Update active button state
        document.getElementById('viewModeStandard').classList.toggle('bg-gray-700', mode === 'standard');
        document.getElementById('viewModeDetailed').classList.toggle('bg-gray-700', mode === 'detailed');
        document.getElementById('viewModeCompare').classList.toggle('bg-gray-700', mode === 'compare');
        
        // Update displays when switching modes
        if (mode === 'detailed' || mode === 'compare') {
            updateFramesDisplay();
            updatePageSequenceDisplay();
        }
    }

    // Show the comparison view with all algorithms
    function showComparisonView() {
        const input = document.getElementById('pageSequence').value;
        const sequence = input.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
        
        if (sequence.length === 0) {
            addLog("Error: Please enter a valid page sequence", "error");
            return;
        }
        
        // Run all algorithms
        const results = {};
        const algorithms = ['fifo', 'lru', 'optimal', 'clock', 'nfu', 'secondChance', 'workingSet'];
        
        algorithms.forEach(algo => {
            // Save current state
            const currentAlgo = algorithm;
            const currentFrames = [...frames];
            const currentIndex = currentPageIndex;
            const currentStats = {...stats};
            const currentState = JSON.parse(JSON.stringify(algorithm_state));
            
            // Run the algorithm
            algorithm = algo;
            resetSimulationState();
            pageSequence = [...sequence];
            
            for (let i = 0; i < pageSequence.length; i++) {
                currentPageIndex = i;
                const page = pageSequence[i];
                
                switch (algorithm) {
                    case "fifo": fifo(page); break;
                    case "lru": lru(page); break;
                    case "optimal": optimal(page); break;
                    case "clock": clock(page); break;
                }
            }
            
            // Save results
            results[algo] = {
                faults: stats.faults,
                hits: stats.hits,
                frames: [...frames],
                hitRate: Math.round((stats.hits / (stats.hits + stats.faults)) * 100) || 0
            };
            
            // Restore state
            algorithm = currentAlgo;
            frames = [...currentFrames];
            currentPageIndex = currentIndex;
            stats = {...currentStats};
            algorithm_state = JSON.parse(JSON.stringify(currentState));
        });
        
        // Update comparison view
        updateComparisonView(results);
        setViewMode('compare');
    }

    // Update the comparison view with results
    function updateComparisonView(results) {
        // Update frames display for each algorithm
        updateAlgorithmFrames('fifo', results.fifo.frames);
        updateAlgorithmFrames('lru', results.lru.frames);
        updateAlgorithmFrames('optimal', results.optimal.frames);
        updateAlgorithmFrames('clock', results.clock.frames);
        
        // Update stats
        document.getElementById('fifoFaults').textContent = results.fifo.faults;
        document.getElementById('lruFaults').textContent = results.lru.faults;
        document.getElementById('optimalFaults').textContent = results.optimal.faults;
        document.getElementById('clockFaults').textContent = results.clock.faults;
        
        document.getElementById('fifoHitRate').textContent = `${results.fifo.hitRate}%`;
        document.getElementById('lruHitRate').textContent = `${results.lru.hitRate}%`;
        document.getElementById('optimalHitRate').textContent = `${results.optimal.hitRate}%`;
        document.getElementById('clockHitRate').textContent = `${results.clock.hitRate}%`;
        
        // Update chart
        window.comparisonChart.data.datasets[0].data = [
            results.fifo.faults,
            results.lru.faults,
            results.optimal.faults,
            results.clock.faults
        ];
        window.comparisonChart.update();
    }

    // Update frames display for a specific algorithm in comparison view
    function updateAlgorithmFrames(algorithm, algoFrames) {
        const container = document.getElementById(`${algorithm}Frames`);
        container.innerHTML = "";
        
        for (let i = 0; i < frameCount; i++) {
            const frame = document.createElement('div');
            frame.classList.add('w-8', 'h-8', 'flex', 'items-center', 'justify-center', 'rounded', 'bg-gray-800', 'border', 'border-gray-700');
            
            if (i < algoFrames.length) {
                frame.textContent = algoFrames[i];
            }
            
            container.appendChild(frame);
        }
    }

    // Page replacement algorithms implementation
    function fifo(page) {
        if (frames.includes(page)) {
            return "hit";
        }
        
        if (frames.length < frameCount) {
            frames.push(page);
            return "fault";
        }
        
        frames[algorithm_state.fifo.pointer] = page;
        algorithm_state.fifo.pointer = (algorithm_state.fifo.pointer + 1) % frameCount;
        return "fault";
    }

    function lru(page) {
        algorithm_state.lru.counter++;
        
        if (frames.includes(page)) {
            algorithm_state.lru.timestamps[page] = algorithm_state.lru.counter;
            return "hit";
        }
        
        if (frames.length < frameCount) {
            frames.push(page);
            algorithm_state.lru.timestamps[page] = algorithm_state.lru.counter;
            return "fault";
        }
        
        let leastRecentPage = frames[0];
        for (const frame of frames) {
            if (algorithm_state.lru.timestamps[frame] < algorithm_state.lru.timestamps[leastRecentPage]) {
                leastRecentPage = frame;
            }
        }
        
        const index = frames.indexOf(leastRecentPage);
        frames[index] = page;
        algorithm_state.lru.timestamps[page] = algorithm_state.lru.counter;
        return "fault";
    }

    function optimal(page) {
        if (frames.includes(page)) {
            return "hit";
        }
        
        if (frames.length < frameCount) {
            frames.push(page);
            return "fault";
        }
        
        // Find page that will not be used for the longest time
        let farthestPage = -1;
        let farthestDistance = -1;
        
        for (const frame of frames) {
            let nextUseIndex = pageSequence.findIndex(
                (p, i) => i > currentPageIndex && p === frame
            );
            
            if (nextUseIndex === -1) {
                // Page never used again, replace it
                farthestPage = frame;
                break;
            }
            
            const distance = nextUseIndex - currentPageIndex;
            if (distance > farthestDistance) {
                farthestDistance = distance;
                farthestPage = frame;
            }
        }
        
        const index = frames.indexOf(farthestPage);
        frames[index] = page;
        return "fault";
    }

    function clock(page) {
        if (frames.includes(page)) {
            algorithm_state.clock.referenced[page] = 1;
            return "hit";
        }
        
        if (frames.length < frameCount) {
            frames.push(page);
            algorithm_state.clock.referenced[page] = 1;
            return "fault";
        }
        
        // Find a page to replace using the clock algorithm
        while (true) {
            const current = frames[algorithm_state.clock.pointer];
            if (algorithm_state.clock.referenced[current] === 0) {
                frames[algorithm_state.clock.pointer] = page;
                algorithm_state.clock.referenced[page] = 1;
                algorithm_state.clock.pointer = (algorithm_state.clock.pointer + 1) % frameCount;
                return "fault";
            }
            algorithm_state.clock.referenced[current] = 0;
            algorithm_state.clock.pointer = (algorithm_state.clock.pointer + 1) % frameCount;
        }
    }

    function nfu(page) {
        if (frames.includes(page)) {
            algorithm_state.nfu.counters[page] = (algorithm_state.nfu.counters[page] || 0) + 1;
            return "hit";
        }
        
        if (frames.length < frameCount) {
            frames.push(page);
            algorithm_state.nfu.counters[page] = 1;
            return "fault";
        }
        
        let leastFrequent = frames[0];
        for (const frame of frames) {
            if ((algorithm_state.nfu.counters[frame] || 0) < (algorithm_state.nfu.counters[leastFrequent] || 0)) {
                leastFrequent = frame;
            }
        }
        
        const index = frames.indexOf(leastFrequent);
        frames[index] = page;
        algorithm_state.nfu.counters[page] = 1;
        return "fault";
    }

    function secondChance(page) {
        if (frames.includes(page)) {
            algorithm_state.secondChance.secondChance[page] = 1;
            return "hit";
        }
        
        if (frames.length < frameCount) {
            frames.push(page);
            algorithm_state.secondChance.secondChance[page] = 0;
            return "fault";
        }
        
        while (true) {
            const current = frames[algorithm_state.secondChance.pointer];
            if (algorithm_state.secondChance.secondChance[current] === 0) {
                frames[algorithm_state.secondChance.pointer] = page;
                algorithm_state.secondChance.secondChance[page] = 0;
                algorithm_state.secondChance.pointer = (algorithm_state.secondChance.pointer + 1) % frameCount;
                return "fault";
            }
            algorithm_state.secondChance.secondChance[current] = 0;
            algorithm_state.secondChance.pointer = (algorithm_state.secondChance.pointer + 1) % frameCount;
        }
    }

    function workingSet(page) {
        const currentTime = ++algorithm_state.workingSet.timestamps.time;
        
        if (frames.includes(page)) {
            algorithm_state.workingSet.timestamps[page] = currentTime;
            return "hit";
        }
        
        if (frames.length < frameCount) {
            frames.push(page);
            algorithm_state.workingSet.timestamps[page] = currentTime;
            return "fault";
        }
        
        // Find the page that's been outside the working set for longest
        let oldestPage = frames[0];
        let oldestTime = algorithm_state.workingSet.timestamps[oldestPage];
        
        for (const frame of frames) {
            const timestamp = algorithm_state.workingSet.timestamps[frame];
            if (timestamp < oldestTime) {
                oldestTime = timestamp;
                oldestPage = frame;
            }
        }
        
        const index = frames.indexOf(oldestPage);
        frames[index] = page;
        algorithm_state.workingSet.timestamps[page] = currentTime;
        return "fault";
    }

    // Update algorithm state display for detailed view
    function updateAlgorithmStateDisplay() {
        const stateEl = document.getElementById('algorithmState');
        if (!stateEl) return;
        
        let stateInfo = "";
        
        switch (algorithm) {
            case "fifo":
                stateInfo = `Pointer: ${algorithm_state.fifo.pointer}`;
                break;
            case "lru":
                stateInfo = `Counter: ${algorithm_state.lru.counter}<br>`;
                stateInfo += `Timestamps: ${JSON.stringify(algorithm_state.lru.timestamps)}`;
                break;
            case "clock":
                stateInfo = `Pointer: ${algorithm_state.clock.pointer}<br>`;
                stateInfo += `Reference bits: ${JSON.stringify(algorithm_state.clock.referenced)}`;
                break;
            case "nfu":
                stateInfo = `Counters: ${JSON.stringify(algorithm_state.nfu.counters)}`;
                break;
            case "secondChance":
                stateInfo = `Pointer: ${algorithm_state.secondChance.pointer}<br>`;
                stateInfo += `Second chance bits: ${JSON.stringify(algorithm_state.secondChance.secondChance)}`;
                break;
            case "workingSet":
                stateInfo = `Current time: ${algorithm_state.workingSet.timestamps.time}<br>`;
                stateInfo += `Timestamps: ${JSON.stringify(algorithm_state.workingSet.timestamps)}`;
                break;
            default:
                stateInfo = "No special state information";
        }
        
        stateEl.innerHTML = stateInfo;
    }

    // Update step details for detailed view
    function updateStepDetails(page, result) {
        const stepDetails = document.getElementById('stepDetailsContent');
        if (!stepDetails) return;
        
        let details = `<strong>Step ${currentPageIndex + 1}:</strong> Page ${page} - ${result.toUpperCase()}<br>`;
        details += `<strong>Frames:</strong> [${frames.join(', ')}]<br>`;
        
        switch (algorithm) {
            case "fifo":
                details += `<strong>FIFO Pointer:</strong> ${algorithm_state.fifo.pointer}`;
                break;
            case "lru":
                details += `<strong>LRU Timestamps:</strong> ${JSON.stringify(algorithm_state.lru.timestamps)}`;
                break;
            case "optimal":
                details += "Optimal algorithm looks ahead in the sequence to make replacement decisions";
                break;
            case "clock":
                details += `<strong>Clock Pointer:</strong> ${algorithm_state.clock.pointer}<br>`;
                details += `<strong>Reference Bits:</strong> ${JSON.stringify(algorithm_state.clock.referenced)}`;
                break;
            case "nfu":
                details += `<strong>NFU Counters:</strong> ${JSON.stringify(algorithm_state.nfu.counters)}`;
                break;
            case "secondChance":
                details += `<strong>Second Chance Pointer:</strong> ${algorithm_state.secondChance.pointer}<br>`;
                details += `<strong>Second Chance Bits:</strong> ${JSON.stringify(algorithm_state.secondChance.secondChance)}`;
                break;
            case "workingSet":
                details += `<strong>Working Set Timestamps:</strong> ${JSON.stringify(algorithm_state.workingSet.timestamps)}`;
                break;
        }
        
        stepDetails.innerHTML = details;
        document.getElementById('stepDetails').classList.remove('hidden');
    }

    // Toggle step details visibility
    function toggleStepDetails() {
        const details = document.getElementById('stepDetails');
        details.classList.toggle('hidden');
    }

    // Save current simulation state
    function saveState() {
        const state = {
            algorithm,
            frames: [...frames],
            pageSequence: [...pageSequence],
            currentPageIndex,
            stats: {...stats},
            algorithm_state: JSON.parse(JSON.stringify(algorithm_state))
        };
        
        localStorage.setItem('pageReplacementSimState', JSON.stringify(state));
        addLog("Simulation state saved", "info");
    }

    // Load saved simulation state
    function loadState() {
        const savedState = localStorage.getItem('pageReplacementSimState');
        if (!savedState) {
            addLog("No saved state found", "error");
            return;
        }
        
        try {
            const state = JSON.parse(savedState);
            
            algorithm = state.algorithm;
            frames = [...state.frames];
            pageSequence = [...state.pageSequence];
            currentPageIndex = state.currentPageIndex;
            stats = {...state.stats};
            algorithm_state = JSON.parse(JSON.stringify(state.algorithm_state));
            
            // Update UI
            document.getElementById('algorithm').value = algorithm;
            document.getElementById('pageSequence').value = pageSequence.join(',');
            updateFramesDisplay();
            updatePageSequenceDisplay();
            updateStats();
            updateAlgorithmInfo();
            
            addLog("Simulation state loaded", "info");
        } catch (e) {
            addLog("Error loading saved state", "error");
            console.error(e);
        }
    }

    // Add bookmark to current state
    function addBookmark() {
        if (currentPageIndex < 0) {
            addLog("Cannot bookmark - simulation not started", "error");
            return;
        }
        
        const bookmarksList = document.getElementById('bookmarksList');
        if (!bookmarksList) return;
        
        bookmarksList.classList.remove('hidden');
        
        const bookmark = document.createElement('div');
        bookmark.classList.add('flex', 'justify-between', 'items-center', 'mb-2', 'p-2', 'bg-gray-700', 'rounded');
        
        const bookmarkText = document.createElement('span');
        bookmarkText.textContent = `Step ${currentPageIndex + 1}: Page ${pageSequence[currentPageIndex]}, Frames: [${frames.join(', ')}]`;
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.classList.add('text-red-400', 'hover:text-red-300', 'cursor-pointer');
        deleteBtn.addEventListener('click', () => bookmark.remove());
        
        bookmark.appendChild(bookmarkText);
        bookmark.appendChild(deleteBtn);
        bookmarksList.appendChild(bookmark);
        
        addLog("Bookmark added", "info");
    }

    // Export visualization as image
    function exportVisualization() {
        const exportContent = document.querySelector('.sim-container:nth-child(2)');
        
        html2canvas(exportContent).then(canvas => {
            const preview = document.getElementById('exportPreview');
            preview.innerHTML = '';
            preview.appendChild(canvas);
            
            // Store canvas for download
            preview.dataset.canvas = canvas.toDataURL('image/png');
            
            // Show modal
            document.getElementById('exportModal').style.display = 'flex';
        });
    }

    // Download exported image
    function downloadExport() {
        const link = document.createElement('a');
        link.download = 'page-replacement-simulation.png';
        link.href = document.getElementById('exportPreview').dataset.canvas;
        link.click();
        closeExportModal();
    }

    // Close export modal
    function closeExportModal() {
        document.getElementById('exportModal').style.display = 'none';
    }

    // Close compare modal
    function closeCompareModal() {
        document.getElementById('compareModal').style.display = 'none';
    }

    // Close algorithm modal
    function closeAlgorithmModal() {
        document.getElementById('algorithmModal').style.display = 'none';
    }

    // Show algorithm GIF tooltip
    function showAlgorithmGif(algorithm) {
        const gifUrl = {
            fifo: 'https://upload.wikimedia.org/wikipedia/commons/6/6c/FIFO-Page-Replacement.gif',
            lru: 'https://upload.wikimedia.org/wikipedia/commons/8/88/LRU.gif',
            optimal: 'https://www.gatevidyalay.com/wp-content/uploads/2018/09/Optimal-Page-Replacement-Algorithm-Example.png',
            clock: 'https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter9/9_15_ClockPageReplacement.jpg',
            nfu: 'https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter9/9_20_CountingAlgorithm.jpg',
            secondChance: 'https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter9/9_16_ClockPageReplacement.jpg',
            workingSet: 'https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter9/9_22_WorkingSetModel.jpg'
        };
        
        let gifTooltip = document.getElementById(`${algorithm}Gif`);
        if (!gifTooltip) {
            gifTooltip = document.createElement('div');
            gifTooltip.id = `${algorithm}Gif`;
            gifTooltip.className = 'gif-tooltip';
            document.body.appendChild(gifTooltip);
        }
        
        if (gifUrl[algorithm]) {
            gifTooltip.innerHTML = `<img src="${gifUrl[algorithm]}" width="200">`;
            gifTooltip.style.display = 'block';
            gifTooltip.style.left = `${event.clientX + 10}px`;
            gifTooltip.style.top = `${event.clientY + 10}px`;
        }
    }

    // Hide GIF tooltip
    function hideGifTooltip() {
        document.querySelectorAll('.gif-tooltip').forEach(tooltip => {
            tooltip.style.display = 'none';
        });
    }

    // Toggle theme between light and dark
    function toggleTheme() {
        document.body.classList.toggle('light-theme');
        const themeToggle = document.getElementById('themeToggle');
        themeToggle.textContent = document.body.classList.contains('light-theme') ? '🌞' : '🌙';
    }

    // Setup tutorial content
    function setupTutorial() {
        const tutorialContent = document.getElementById('tutorialContent');
        tutorialContent.innerHTML = `
            <div class="tutorial-step" data-step="1">
                <h3 class="font-bold mb-2">Welcome to the Page Replacement Simulator</h3>
                <p>This tool helps you visualize how different page replacement algorithms work in operating systems.</p>
            </div>
            <div class="tutorial-step hidden" data-step="2">
                <h3 class="font-bold mb-2">How to Use</h3>
                <ol class="list-decimal pl-5 space-y-1">
                    <li>Enter a page sequence or use a preset</li>
                    <li>Select the number of frames (1-5)</li>
                    <li>Choose an algorithm</li>
                    <li>Click Start or Step through</li>
                </ol>
            </div>
            <div class="tutorial-step hidden" data-step="3">
                <h3 class="font-bold mb-2">Algorithms Explained</h3>
                <ul class="list-disc pl-5 space-y-1">
                    <li><strong>FIFO:</strong> Replaces the oldest page</li>
                    <li><strong>LRU:</strong> Replaces least recently used page</li>
                    <li><strong>Optimal:</strong> Replaces page not needed for longest time (theoretical)</li>
                    <li><strong>Clock:</strong> Approximation of LRU with lower overhead</li>
                </ul>
            </div>
            <div class="tutorial-step hidden" data-step="4">
                <h3 class="font-bold mb-2">Visualization</h3>
                <p>The simulation shows:</p>
                <ul class="list-disc pl-5 space-y-1">
                    <li>Current memory frames</li>
                    <li>Page sequence with hits/faults</li>
                    <li>Algorithm-specific information</li>
                    <li>Performance statistics</li>
                </ul>
            </div>
            <div class="tutorial-step hidden" data-step="5">
                <h3 class="font-bold mb-2">Advanced Features</h3>
                <ul class="list-disc pl-5 space-y-1">
                    <li>Compare multiple algorithms</li>
                    <li>Save/Load simulation state</li>
                    <li>Bookmark interesting steps</li>
                    <li>Export visualizations</li>
                </ul>
            </div>
            <div class="tutorial-step hidden" data-step="6">
                <h3 class="font-bold mb-2">Ready to Start!</h3>
                <p>Try different sequences and algorithms to see how they perform.</p>
                <p class="mt-2 text-blue-400">Tip: Use the presets menu for interesting test cases.</p>
            </div>
        `;
    }

    // Show tutorial modal
    function showTutorial() {
        document.getElementById('tutorialModal').style.display = 'flex';
        document.querySelector('[data-step="1"]').classList.remove('hidden');
        document.getElementById('tutorialStep').textContent = 'Step 1/6';
    }

    // Close tutorial modal
    function closeTutorial() {
        document.getElementById('tutorialModal').style.display = 'none';
    }

    // Go to next tutorial step
    function tutorialNext() {
        const currentStep = document.querySelector('.tutorial-step:not(.hidden)').dataset.step;
        const nextStep = parseInt(currentStep) + 1;
        
        if (nextStep > 6) {
            closeTutorial();
            return;
        }
        
        document.querySelector(`[data-step="${currentStep}"]`).classList.add('hidden');
        document.querySelector(`[data-step="${nextStep}"]`).classList.remove('hidden');
        document.getElementById('tutorialStep').textContent = `Step ${nextStep}/6`;
    }

    // Go to previous tutorial step
    function tutorialPrev() {
        const currentStep = document.querySelector('.tutorial-step:not(.hidden)').dataset.step;
        const prevStep = parseInt(currentStep) - 1;
        
        if (prevStep < 1) return;
        
        document.querySelector(`[data-step="${currentStep}"]`).classList.add('hidden');
        document.querySelector(`[data-step="${prevStep}"]`).classList.remove('hidden');
        document.getElementById('tutorialStep').textContent = `Step ${prevStep}/6`;
    }
</script>
</body>
</html>